<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>AR image • smooth drag & pinch</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto; }
    #enter { position: fixed; left: 16px; top: 16px; z-index: 5; }
    #ui { position: fixed; inset: 0; pointer-events:none; display:flex; align-items:flex-end; justify-content:center; padding: 16px; }
    #hint { pointer-events:none; color:white; text-shadow:0 1px 2px rgba(0,0,0,.6); background: rgba(0,0,0,.25); padding:6px 10px; border-radius:999px; font-size:14px; }
    button { pointer-events:auto; padding:10px 14px; border-radius:10px; border:1px solid #ddd; background:#fff; font-weight:600; }
  </style>
</head>
<body>
  <button id="enter">Start AR</button>
  <div id="ui"><div id="hint">tap to place • drag (press) • pinch to resize</div></div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
  (async function () {
    const IMAGE_URL = 'https://images.unsplash.com/photo-1529626455594-4ff0802cfb7e?w=1200&q=80&auto=format&fit=crop';

    let renderer, scene, camera, reticle, imageMesh, controller;
    let hitTestSource = null, transientHitTestSource = null;
    let dragging = false;

    // smoothing state
    const targetPos = new THREE.Vector3();
    const vel = new THREE.Vector3();
    const tmpQuat = new THREE.Quaternion();
    let targetScale = 1;

    // pinch state (world-space)
    let pinching = false;
    let basePinchDist = 0;
    let baseScale = 1;

    const enterBtn = document.getElementById('enter');

    init();

    function init() {
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5)); // lower = smoother
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      if (!navigator.xr) {
        alert('WebXR AR not available on this device/browser.');
        return;
      }

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera();
      scene.add(camera);

      scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 0.7));

      reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI/2),
        new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.75 })
      );
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelectPlace);
      controller.addEventListener('selectstart', () => dragging = true);
      controller.addEventListener('selectend', () => { dragging = false; pinching = false; basePinchDist = 0; });
      scene.add(controller);

      window.addEventListener('resize', () => renderer.setSize(window.innerWidth, window.innerHeight));
      enterBtn.addEventListener('click', startAR);

      // minimal pointer bookkeeping to know when two fingers are down
      const down = new Set();
      document.addEventListener('pointerdown', (e) => { down.add(e.pointerId); if (down.size === 2) startPinch(); }, { passive: true });
      document.addEventListener('pointerup',   (e) => { down.delete(e.pointerId); if (down.size < 2) endPinch(); },   { passive: true });
      document.addEventListener('pointercancel',(e)=> { down.delete(e.pointerId); if (down.size < 2) endPinch(); },   { passive: true });

      function startPinch(){ if (imageMesh?.visible) pinching = true; }
      function endPinch(){ pinching = false; basePinchDist = 0; }
    }

    async function startAR() {
      const sessionInit = {
        requiredFeatures: ['hit-test'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: document.body }
      };
      const session = await navigator.xr.requestSession('immersive-ar', sessionInit);

      const viewerSpace = await session.requestReferenceSpace('viewer');
      hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

      try {
        transientHitTestSource = await session.requestHitTestSourceForTransientInput({ profile: 'screen-touch' });
      } catch (e) {
        transientHitTestSource = null;
      }

      renderer.xr.setReferenceSpaceType('local');
      await renderer.xr.setSession(session);

      enterBtn.style.display = 'none';
      renderer.setAnimationLoop(renderAR);

      if (!imageMesh) {
        imageMesh = await makeImagePlane(IMAGE_URL);
        imageMesh.visible = false;
        scene.add(imageMesh);
      }
    }

    async function makeImagePlane(url) {
      const tex = await new THREE.TextureLoader().loadAsync(url);
      tex.colorSpace = THREE.SRGBColorSpace;
      const aspect = tex.image.width / tex.image.height;
      const width = 0.6, height = width / aspect;

      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(width, height),
        new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide })
      );
      mesh.matrixAutoUpdate = true;
      targetScale = 1;
      mesh.scale.setScalar(targetScale);
      return mesh;
    }

    function onSelectPlace() {
      if (!reticle.visible || !imageMesh) return;
      imageMesh.visible = true;

      // snap to reticle initially
      const m = new THREE.Matrix4().copy(reticle.matrix);
      imageMesh.position.setFromMatrixPosition(m);

      // face camera, keep upright
      const cam = renderer.xr.getCamera(camera);
      imageMesh.lookAt(cam.position);
      imageMesh.rotation.x = 0;
      imageMesh.rotation.z = 0;

      // set smoothing targets
      targetPos.copy(imageMesh.position);
      targetScale = imageMesh.scale.x;
      vel.set(0,0,0);
    }

    // critically-damped spring toward target (per-axis)
    function smoothDamp(current, target, velocity, smoothTime, delta) {
      const omega = 2 / Math.max(0.0001, smoothTime);
      const x = omega * delta;
      const exp = 1 / (1 + x + 0.48*x*x + 0.235*x*x*x);
      const change = current.clone().sub(target);
      const temp = velocity.clone().addScaledVector(change, omega).multiplyScalar(delta);
      const newVel = velocity.clone().sub(temp.multiplyScalar(omega)).multiplyScalar(exp);
      const newPos = current.clone().sub(change).addScaledVector(temp, exp);
      return { pos: newPos, vel: newVel };
    }

    function renderAR(t, frame) {
      const refSpace = renderer.xr.getReferenceSpace();
      if (!frame || !refSpace) { renderer.render(scene, camera); return; }
      const dt = Math.min(0.05, renderer.xr.isPresenting ? (frame.getViewerPose(refSpace) ? 1/60 : 1/60) : 1/60); // approx; browsers hide true dt

      // center-screen hit test for reticle
      if (hitTestSource) {
        const hits = frame.getHitTestResults(hitTestSource);
        if (hits.length) {
          const pose = hits[0].getPose(refSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else {
          reticle.visible = false;
        }
      }

      if (imageMesh?.visible) {
        // DRAG: use transient hit under finger to set target position; smooth toward it
        if (dragging && transientHitTestSource) {
          const trs = frame.getHitTestResultsForTransientInput(transientHitTestSource);
          if (trs.length && trs[0].results.length) {
            const pose = trs[0].results[0].getPose(refSpace);
            targetPos.setFromMatrixPosition(new THREE.Matrix4().fromArray(pose.transform.matrix));
          }
        }

        // PINCH: compute world-space distance between first two touches
        if (pinching && transientHitTestSource) {
          const trs = frame.getHitTestResultsForTransientInput(transientHitTestSource);
          if (trs.length >= 2 && trs[0].results.length && trs[1].results.length) {
            const p0 = new THREE.Vector3().setFromMatrixPosition(new THREE.Matrix4().fromArray(trs[0].results[0].getPose(refSpace).transform.matrix));
            const p1 = new THREE.Vector3().setFromMatrixPosition(new THREE.Matrix4().fromArray(trs[1].results[0].getPose(refSpace).transform.matrix));
            const dist = p0.distanceTo(p1);

            if (basePinchDist === 0) {
              basePinchDist = dist;
              baseScale = targetScale;
            } else if (dist > 0) {
              const raw = (dist / basePinchDist) * baseScale;
              // ease the target scale; clamp range
              targetScale = THREE.MathUtils.clamp(raw, 0.2, 4.0);
            }
          }
        }

        // smooth position
        const s = smoothDamp(imageMesh.position, targetPos, vel, /*smoothTime*/ 0.06, dt);
        imageMesh.position.copy(s.pos); vel.copy(s.vel);

        // face camera, keep upright (also smoothed a bit)
        const cam = renderer.xr.getCamera(camera);
        imageMesh.lookAt(cam.position);
        imageMesh.rotation.x = 0;
        imageMesh.rotation.z = 0;

        // smooth scale (lerp)
        const k = 1 - Math.pow(0.0001, dt * 60); // frame-rate independent
        const newScale = THREE.MathUtils.lerp(imageMesh.scale.x, targetScale, k);
        imageMesh.scale.setScalar(newScale);
      }

      renderer.render(scene, camera);
    }
  })();
  </script>
</body>
</html>
